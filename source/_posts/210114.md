---
title: 彻底理解浮动清除
toc: true
reward: false
copyright: false
article_type: 0
tags:
  - HTML
  - 笔记
abbrlink: 57121fb5
date: 2021-01-14 20:21:16
---

![20210920932039](https://cdn.jsdelivr.net/gh/Anyway521/blogpic2@main/image/20210920932039.jpg)

本文介绍了四种清除浮动的方法，并尝试解释其原理。
<!-- more -->
# 1、为什么要清除浮动？
先看一个例子(`父容器包含了两个孩子 `)：
``` html
<div class="Father">
    <div class="son_01_float">son_01</div>
    <div class="son_02">son_02</div>
</div>
```

给出样式：
``` css
.Father {
    width: 500px;
    border: 2px solid black;
}
.son_01_float {
    width: 100px;
    height: 100px;
    border: 2px dotted red;
    color: red;
    margin: 4px;
    float: left;
}
.son_02 {
    color: blue;
    border: 2px solid blue;
}
```
注意以下几点：
>1、父容器没有给高度  
>2、son_01声明了左浮动

效果如下：

![20210115210246](https://cdn.jsdelivr.net/gh/Anyway521/blogpic2@main/image/20210115210246.png)

想象一下，`son_01`飘起来，不占位置，下面躺着`son_02`,而父容器的`高度`是由`son_02`撑起的。
# 2、清除浮动的方法
## 1）给`son_02`声明`clear`属性
``` css
.son_02 {
    color: blue;
    border: 2px solid blue;
    clear:left
    /*son_02告诉浏览器，清除我左边的浮动元素*/
}
```
效果如下：

![20210115211259](https://cdn.jsdelivr.net/gh/Anyway521/blogpic2@main/image/20210115211259.png)

父元素的高度被`撑起来`，把`son_01`和`son_02`都包围住了

## *假如，对换一下两个儿子的位置（让son_02先占据位置）
``` html
<div class="Father">
    <div class="son_02">son_02</div>
    <div class="son_01_float">son_01</div>
</div>
```
效果如下：

![20210115211655](https://cdn.jsdelivr.net/gh/Anyway521/blogpic2@main/image/20210115211655.png)

这时候如果还给`son_02`声明`clear:left`,就会发现clear失效了，因为这时候`son_02`左边本来就没有浮动元素。于是乎引出下一种方法。

## 2）用空元素清除浮动
在`父容器结束标签前`加一个`块级`空元素

``` html
<div class="Father">
    <div class="son_02">son_02</div>
    <div class="son_01_float">son_01</div>
    <div class="son_03"></div>
    /*三儿子*/
</div>
```
然后给三儿子添加clear属性
``` css
.son_03{
    clear:left
}
```
效果如下：

![20210115212948](https://cdn.jsdelivr.net/gh/Anyway521/blogpic2@main/image/20210115212948.png)


## 3）父元素使用overflow属性

还是上面的场景，不用添加`son_03`,直接给father声明`overflow:hidden`,也能达到一样的效果。

## 4）使用伪类元素
还是对父元素动刀。
``` html
<div class="Father clearfix">
    /*再给父亲添加一个类名*/
    <div class="son_02">son_02</div>
    <div class="son_01_float">son_01</div>
</div>
```
声明伪类元素`:after`
``` css
.clearfix:after{
    content:"";
    display:block;
    clear:both;
    visibility:hidden;
    height:0;
    overflow:hidden;
    /*后三句是为了旧版本浏览器兼容性*/
}  
```

##  *一个易混淆的小案例
代码：
``` html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        .box1{
            width: 100px;
            height: 100px;
            background: yellow;
            float: left;
        }
        .box2{
            width: 120px;
            height: 120px;
            background: blue;
        }
    </style>
</head>
<body>
   
    <div class="box1"></div>
    <div class="box2"></div>
</body>
</html>
```
效果如下(黄色盒子在前，蓝色盒子在后，黄盒声明浮动)：
<style>
.box1{width: 100px;height: 100px;background: yellow;float: left;}
.box2{width: 120px;height: 120px;background: blue;}
</style>
<div class="box1"></div>
<div class="box2"></div>
<br>  


样式一：
``` css
.box2{
    overflow:hidden;
}
```
>特别注意，这里不是在给父元素清除浮动，只是.box2触发了BFC   

效果（.box2向右移动,与box1左右重叠）：
<style>
.box11{width: 100px;height: 100px;background: yellow;float: left;}
.box22{width: 120px;height: 120px;background: blue;overflow:hidden}
</style>
<div class="box11"></div>
<div class="box22"></div>

样式二：
``` css
.box2{
    clear:left;
}
```
效果（.box2向下移动,与box1上下重叠）：
<style>
.box111{width: 100px;height: 100px;background: yellow;float: left;}
.box222{width: 120px;height: 120px;background: blue;clear:left}
</style>
<div class="box111"></div>
<div class="box222"></div>
<br>
这才是在清楚浮动
